diff --git a/src/node_crypto.cc b/src/node_crypto.cc
index c3779c0..611fb43 100644
--- a/src/node_crypto.cc
+++ b/src/node_crypto.cc
@@ -19,6 +19,11 @@
 #include <stdlib.h>
 #include <string.h>
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#define X509_get0_notBefore X509_get_notBefore
+#define X509_get0_notAfter X509_get_notAfter
+#endif
+
 #define THROW_AND_RETURN_IF_NOT_STRING_OR_BUFFER(val, prefix)                  \
   do {                                                                         \
     if (!Buffer::HasInstance(val) && !val->IsString()) {                       \
@@ -344,6 +349,7 @@
       method = SSLv23_server_method();
     } else if (strcmp(*sslmethod, "SSLv23_client_method") == 0) {
       method = SSLv23_client_method();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     } else if (strcmp(*sslmethod, "TLSv1_method") == 0) {
       method = TLSv1_method();
     } else if (strcmp(*sslmethod, "TLSv1_server_method") == 0) {
@@ -362,6 +368,14 @@
       method = TLSv1_2_server_method();
     } else if (strcmp(*sslmethod, "TLSv1_2_client_method") == 0) {
       method = TLSv1_2_client_method();
+#else
+    } else if (strcmp(*sslmethod, "TLS_method") == 0) {
+      method = TLS_method();
+    } else if (strcmp(*sslmethod, "TLS_server_method") == 0) {
+      method = TLS_server_method();
+    } else if (strcmp(*sslmethod, "TLS_client_method") == 0) {
+      method = TLS_client_method();
+#endif
     } else {
       return env->ThrowError("Unknown method");
     }
@@ -1552,14 +1566,14 @@
     rsa = nullptr;
   }
 
-  ASN1_TIME_print(bio, X509_get_notBefore(cert));
+  ASN1_TIME_print(bio, X509_get0_notBefore(cert));
   BIO_get_mem_ptr(bio, &mem);
   info->Set(env->valid_from_string(),
             String::NewFromUtf8(env->isolate(), mem->data,
                                 String::kNormalString, mem->length));
   (void) BIO_reset(bio);
 
-  ASN1_TIME_print(bio, X509_get_notAfter(cert));
+  ASN1_TIME_print(bio, X509_get0_notAfter(cert));
   BIO_get_mem_ptr(bio, &mem);
   info->Set(env->valid_to_string(),
             String::NewFromUtf8(env->isolate(), mem->data,
@@ -5994,8 +6008,12 @@
 }
 
 void InitCryptoOnce() {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   SSL_load_error_strings();
   OPENSSL_no_config();
+#else
+  OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG, NULL);
+#endif
 
   // --openssl-config=...
   if (!openssl_config.empty()) {
@@ -6017,12 +6035,14 @@
     }
   }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   SSL_library_init();
   OpenSSL_add_all_algorithms();
 
   crypto_lock_init();
   CRYPTO_set_locking_callback(crypto_lock_cb);
   CRYPTO_THREADID_set_callback(crypto_threadid_cb);
+#endif
 
 #ifdef NODE_FIPS_MODE
   /* Override FIPS settings in cnf file, if needed. */
diff --git a/src/node_crypto.h b/src/node_crypto.h
index 58f5b72..875a787 100644
--- a/src/node_crypto.h
+++ b/src/node_crypto.h
@@ -16,6 +16,9 @@
 #include "v8.h"
 
 #include <openssl/ssl.h>
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/dh.h>
 #include <openssl/ec.h>
 #include <openssl/ecdh.h>
 #ifndef OPENSSL_NO_ENGINE
@@ -90,8 +93,20 @@
   static const int kTicketKeyNameIndex = 3;
   static const int kTicketKeyIVIndex = 4;
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+  unsigned char ticket_key_name_[16];
+  unsigned char ticket_key_aes_[16];
+  unsigned char ticket_key_hmac_[16];
+#endif
+
  protected:
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   static const int64_t kExternalSize = sizeof(SSL_CTX);
+#else
+  // OpenSSL 1.1.0 has opaque structures. This is an estimate based on the size
+  // as of OpenSSL 1.1.0f.
+  static const int64_t kExternalSize = 872;
+#endif
 
   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void Init(const v8::FunctionCallbackInfo<v8::Value>& args);
@@ -129,6 +144,15 @@
                                HMAC_CTX* hctx,
                                int enc);
 
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+  static int TicketCompatibilityCallback(SSL* ssl,
+                                         unsigned char* name,
+                                         unsigned char* iv,
+                                         EVP_CIPHER_CTX* ectx,
+                                         HMAC_CTX* hctx,
+                                         int enc);
+#endif
+
   SecureContext(Environment* env, v8::Local<v8::Object> wrap)
       : BaseObject(env, wrap),
         ctx_(nullptr),
@@ -205,19 +229,32 @@
  protected:
   typedef void (*CertCb)(void* arg);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   // Size allocated by OpenSSL: one for SSL structure, one for SSL3_STATE and
   // some for buffers.
   // NOTE: Actually it is much more than this
   static const int64_t kExternalSize =
       sizeof(SSL) + sizeof(SSL3_STATE) + 42 * 1024;
+#else
+  // OpenSSL 1.1.0 has opaque structures. This is an estimate based on the size
+  // as of OpenSSL 1.1.0f.
+  static const int64_t kExternalSize = 4448 + 1024 + 42 * 1024;
+#endif
 
   static void InitNPN(SecureContext* sc);
   static void AddMethods(Environment* env, v8::Local<v8::FunctionTemplate> t);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   static SSL_SESSION* GetSessionCallback(SSL* s,
                                          unsigned char* key,
                                          int len,
                                          int* copy);
+#else
+  static SSL_SESSION* GetSessionCallback(SSL* s,
+                                         const unsigned char* key,
+                                         int len,
+                                         int* copy);
+#endif
   static int NewSessionCallback(SSL* s, SSL_SESSION* sess);
   static void OnClientHello(void* arg,
                             const ClientHelloParser::ClientHello& hello);
