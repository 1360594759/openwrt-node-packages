diff -urN a/bignum.cc b/bignum.cc
--- a/bignum.cc	2016-05-31 17:12:00.000000000 +0900
+++ b/bignum.cc	2018-06-29 11:04:25.527500999 +0900
@@ -41,7 +41,7 @@
     Nan::ThrowTypeError("Argument " #I " must be a uint32");    \
     return;                                     \
   }                                                           \
-  uint32_t VAR = info[I]->ToUint32()->Value();
+  uint32_t VAR = Nan::To<int32_t>(info[I]).FromJust();
 
 #define REQ_INT64_ARG(I, VAR)                                 \
   if (info.Length() <= (I) || !info[I]->IsNumber()) {         \
@@ -66,8 +66,8 @@
 
 #define WRAP_RESULT(RES, VAR)                                           \
   Local<Value> arg[1] = { Nan::New<External>(static_cast<BigNum*>(RES)) };  \
-  Local<Object> VAR = Nan::New<FunctionTemplate>(constructor_template)->      \
-    GetFunction()->NewInstance(1, arg);
+  Local<Object> VAR = Nan::NewInstance(Nan::New<FunctionTemplate>(constructor_template)->      \
+    GetFunction(), 1, arg).ToLocalChecked();
 
 class AutoBN_CTX
 {
@@ -140,9 +140,9 @@
   BN_copy(a1,A);
   BN_copy(n1,N);
 startjacobistep1:
-  if BN_is_zero(a1) /* step 1 */
+  if (BN_is_zero(a1)) /* step 1 */
     goto endBN_jacobi;  /* *jacobi = 1; */
-  if BN_is_one(a1) /* step 2 */
+  if (BN_is_one(a1)) /* step 2 */
     goto endBN_jacobi;  /* *jacobi = 1; */
   for (e=0;;e++) /*  step 3 */
     if (BN_is_odd(a1))
@@ -180,14 +180,18 @@
 class BigNum : public Nan::ObjectWrap {
 public:
   static void Initialize(Local<Object> target);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BIGNUM bignum_;
+#else
+  BIGNUM *bignum_;
+#endif
   static Nan::Persistent<Function> js_conditioner;
   static void SetJSConditioner(Local<Function> constructor);
 
 protected:
   static Nan::Persistent<FunctionTemplate> constructor_template;
 
-  BigNum(const String::Utf8Value& str, uint64_t base);
+  BigNum(const Nan::Utf8String& str, uint64_t base);
   BigNum(uint64_t num);
   BigNum(int64_t num);
   BigNum(BIGNUM *num);
@@ -291,20 +295,38 @@
   target->Set(Nan::New("BigNum").ToLocalChecked(), tmpl->GetFunction());
 }
 
-BigNum::BigNum(const v8::String::Utf8Value& str, uint64_t base) : Nan::ObjectWrap ()
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+BigNum::BigNum(const Nan::Utf8String& str, uint64_t base) : Nan::ObjectWrap ()
+#else
+BigNum::BigNum(const Nan::Utf8String& str, uint64_t base) : Nan::ObjectWrap (),
+    bignum_(BN_new())
+#endif
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_init(&bignum_);
   BN_zero(&bignum_);
 
   BIGNUM *res = &bignum_;
+#else
+  BN_zero(bignum_);
+
+  BIGNUM *res = bignum_;
+#endif
+
 
   const char *cstr = *str;
   switch (base) {
   case 2:
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     BN_init(&bignum_);
+#endif
     for (int i = 0, l = str.length(); i < l; i++) {
       if (cstr[l-i-1] != '0') {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         BN_set_bit(&bignum_, i);
+#else
+        BN_set_bit(bignum_, i);
+#endif
       }
     }
     break;
@@ -320,8 +342,14 @@
   }
 }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 BigNum::BigNum(uint64_t num) : Nan::ObjectWrap ()
+#else
+BigNum::BigNum(uint64_t num) : Nan::ObjectWrap (),
+    bignum_(BN_new())
+#endif
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_init(&bignum_);
 
   if (sizeof(BN_ULONG) >= 8 || num <= 0xFFFFFFFFL) {
@@ -331,11 +359,26 @@
     BN_lshift(&bignum_, &bignum_, 32);
     BN_add_word(&bignum_, num & 0xFFFFFFFFL);
   }
+#else
+  if (sizeof(BN_ULONG) >= 8 || num <= 0xFFFFFFFFL) {
+    BN_set_word(bignum_, num);
+  } else {
+    BN_set_word(bignum_, num >> 32);
+    BN_lshift(bignum_, bignum_, 32);
+    BN_add_word(bignum_, num & 0xFFFFFFFFL);
+  }
+#endif
 }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 BigNum::BigNum(int64_t num) : Nan::ObjectWrap ()
+#else
+BigNum::BigNum(int64_t num) : Nan::ObjectWrap (),
+    bignum_(BN_new())
+#endif
 {
   bool neg = (num < 0);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_init(&bignum_);
 
   if (neg) {
@@ -354,23 +397,63 @@
   if (neg) {
     BN_set_negative(&bignum_, 1);
   }
+#else
+  if (neg) {
+    num = -num;
+  }
+  if (num < 0) { // num is -2^63
+    BN_one(bignum_);
+    BN_lshift(bignum_, bignum_, 63);
+  } else if (sizeof(BN_ULONG) >= 8 || num <= 0xFFFFFFFFL) {
+    BN_set_word(bignum_, num);
+  } else {
+    BN_set_word(bignum_, num >> 32);
+    BN_lshift(bignum_, bignum_, 32);
+    BN_add_word(bignum_, num & 0xFFFFFFFFL);
+  }
+  if (neg) {
+    BN_set_negative(bignum_, 1);
+  }
+#endif
 }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 BigNum::BigNum(BIGNUM *num) : Nan::ObjectWrap ()
+#else
+BigNum::BigNum(BIGNUM *num) : Nan::ObjectWrap (),
+    bignum_(BN_new())
+#endif
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_init(&bignum_);
   BN_copy(&bignum_, num);
+#else
+  BN_copy(bignum_, num);
+#endif
 }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 BigNum::BigNum() : Nan::ObjectWrap ()
+#else
+BigNum::BigNum() : Nan::ObjectWrap (),
+    bignum_(BN_new())
+#endif
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_init(&bignum_);
   BN_zero(&bignum_);
+#else
+  BN_zero(bignum_);
+#endif
 }
 
 BigNum::~BigNum()
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_clear_free(&bignum_);
+#else
+  BN_clear_free(bignum_);
+#endif
 }
 
 NAN_METHOD(BigNum::New)
@@ -381,8 +464,15 @@
     for (int i = 0; i < len; i++) {
       newArgs[i] = info[i];
     }
-    Local<Value> newInst = Nan::New<FunctionTemplate>(constructor_template)->
-        GetFunction()->NewInstance(len, newArgs);
+    Nan::TryCatch tryCatch;
+    Nan::MaybeLocal<Object> newInstMaybeLocal = Nan::NewInstance(
+        Nan::New<FunctionTemplate>(constructor_template)->GetFunction(), len, newArgs);
+    if (tryCatch.HasCaught()) {
+        tryCatch.ReThrow();
+        return;
+    }
+
+    Local<Value> newInst = newInstMaybeLocal.ToLocalChecked();
     delete[] newArgs;
     info.GetReturnValue().Set(newInst);
     return;
@@ -409,8 +499,8 @@
       return;
     }
 
-    String::Utf8Value str(obj->ToObject()->Get(Nan::New("num").ToLocalChecked())->ToString());
-    base = obj->ToObject()->Get(Nan::New("base").ToLocalChecked())->ToNumber()->Value();
+    Nan::Utf8String str(obj->ToObject()->Get(Nan::New("num").ToLocalChecked())->ToString());
+    base = Nan::To<int64_t>(obj->ToObject()->Get(Nan::New("base").ToLocalChecked())).FromJust();
 
     bignum = new BigNum(str, base);
   }
@@ -433,10 +523,18 @@
   char *to = NULL;
   switch (base) {
   case 10:
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     to = BN_bn2dec(&bignum->bignum_);
+#else
+    to = BN_bn2dec(bignum->bignum_);
+#endif
     break;
   case 16:
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     to = BN_bn2hex(&bignum->bignum_);
+#else
+    to = BN_bn2hex(bignum->bignum_);
+#endif
     break;
   default:
     Nan::ThrowError("Invalid base, only 10 and 16 are supported");
@@ -456,7 +554,11 @@
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_add(&res->bignum_, &bignum->bignum_, &bn->bignum_);
+#else
+  BN_add(res->bignum_, bignum->bignum_, bn->bignum_);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -469,7 +571,11 @@
 
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_sub(&res->bignum_, &bignum->bignum_, &bn->bignum_);
+#else
+  BN_sub(res->bignum_, bignum->bignum_, bn->bignum_);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -483,7 +589,11 @@
 
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_mul(&res->bignum_, &bignum->bignum_, &bn->bignum_, ctx);
+#else
+  BN_mul(res->bignum_, bignum->bignum_, bn->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -497,7 +607,11 @@
 
   BigNum *bi = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_div(&res->bignum_, NULL, &bignum->bignum_, &bi->bignum_, ctx);
+#else
+  BN_div(res->bignum_, NULL, bignum->bignum_, bi->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -509,6 +623,7 @@
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
   REQ_UINT64_ARG(0, x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BigNum *res = new BigNum(&bignum->bignum_);
   if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
     BN_add_word(&res->bignum_, x);
@@ -516,6 +631,15 @@
     BigNum *bn = new BigNum(x);
     BN_add(&res->bignum_, &bignum->bignum_, &bn->bignum_);
   }
+#else
+  BigNum *res = new BigNum(bignum->bignum_);
+  if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
+    BN_add_word(res->bignum_, x);
+  } else {
+    BigNum *bn = new BigNum(x);
+    BN_add(res->bignum_, bignum->bignum_, bn->bignum_);
+  }
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -527,6 +651,7 @@
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
   REQ_UINT64_ARG(0, x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BigNum *res = new BigNum(&bignum->bignum_);
   if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
     BN_sub_word(&res->bignum_, x);
@@ -534,6 +659,15 @@
     BigNum *bn = new BigNum(x);
     BN_sub(&res->bignum_, &bignum->bignum_, &bn->bignum_);
   }
+#else
+  BigNum *res = new BigNum(bignum->bignum_);
+  if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
+    BN_sub_word(res->bignum_, x);
+  } else {
+    BigNum *bn = new BigNum(x);
+    BN_sub(res->bignum_, bignum->bignum_, bn->bignum_);
+  }
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -545,6 +679,7 @@
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
   REQ_UINT64_ARG(0, x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BigNum *res = new BigNum(&bignum->bignum_);
   if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
     BN_mul_word(&res->bignum_, x);
@@ -553,6 +688,16 @@
     BigNum *bn = new BigNum(x);
     BN_mul(&res->bignum_, &bignum->bignum_, &bn->bignum_, ctx);
   }
+#else
+  BigNum *res = new BigNum(bignum->bignum_);
+  if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
+    BN_mul_word(res->bignum_, x);
+  } else {
+    AutoBN_CTX ctx;
+    BigNum *bn = new BigNum(x);
+    BN_mul(res->bignum_, bignum->bignum_, bn->bignum_, ctx);
+  }
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -564,6 +709,7 @@
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
   REQ_UINT64_ARG(0, x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BigNum *res = new BigNum(&bignum->bignum_);
   if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
     BN_div_word(&res->bignum_, x);
@@ -572,6 +718,16 @@
     BigNum *bn = new BigNum(x);
     BN_div(&res->bignum_, NULL, &bignum->bignum_, &bn->bignum_, ctx);
   }
+#else
+  BigNum *res = new BigNum(bignum->bignum_);
+  if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
+    BN_div_word(res->bignum_, x);
+  } else {
+    AutoBN_CTX ctx;
+    BigNum *bn = new BigNum(x);
+    BN_div(res->bignum_, NULL, bignum->bignum_, bn->bignum_, ctx);
+  }
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -584,7 +740,11 @@
 
   REQ_UINT32_ARG(0, x);
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_lshift(&res->bignum_, &bignum->bignum_, x);
+#else
+  BN_lshift(res->bignum_, bignum->bignum_, x);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -597,7 +757,11 @@
 
   REQ_UINT32_ARG(0, x);
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_rshift(&res->bignum_, &bignum->bignum_, x);
+#else
+  BN_rshift(res->bignum_, bignum->bignum_, x);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -608,8 +772,13 @@
 {
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BigNum *res = new BigNum(&bignum->bignum_);
   BN_set_negative(&res->bignum_, 0);
+#else
+  BigNum *res = new BigNum(bignum->bignum_);
+  BN_set_negative(res->bignum_, 0);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -620,8 +789,13 @@
 {
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BigNum *res = new BigNum(&bignum->bignum_);
   BN_set_negative(&res->bignum_, !BN_is_negative(&res->bignum_));
+#else
+  BigNum *res = new BigNum(bignum->bignum_);
+  BN_set_negative(res->bignum_, !BN_is_negative(res->bignum_));
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -635,7 +809,11 @@
 
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_div(NULL, &res->bignum_, &bignum->bignum_, &bn->bignum_, ctx);
+#else
+  BN_div(NULL, res->bignum_, bignum->bignum_, bn->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -648,6 +826,7 @@
 
   REQ_UINT64_ARG(0, x);
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
     BN_set_word(&res->bignum_, BN_mod_word(&bignum->bignum_, x));
   } else {
@@ -655,6 +834,15 @@
     BigNum *bn = new BigNum(x);
     BN_div(NULL, &res->bignum_, &bignum->bignum_, &bn->bignum_, ctx);
   }
+#else
+  if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
+    BN_set_word(res->bignum_, BN_mod_word(bignum->bignum_, x));
+  } else {
+    AutoBN_CTX ctx;
+    BigNum *bn = new BigNum(x);
+    BN_div(NULL, res->bignum_, bignum->bignum_, bn->bignum_, ctx);
+  }
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -669,7 +857,11 @@
   BigNum *bn1 = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *bn2 = Nan::ObjectWrap::Unwrap<BigNum>(info[1]->ToObject());
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_mod_exp(&res->bignum_, &bignum->bignum_, &bn1->bignum_, &bn2->bignum_, ctx);
+#else
+  BN_mod_exp(res->bignum_, bignum->bignum_, bn1->bignum_, bn2->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -686,7 +878,11 @@
   BigNum *exp = new BigNum(x);
 
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_mod_exp(&res->bignum_, &bignum->bignum_, &exp->bignum_, &bn->bignum_, ctx);
+#else
+  BN_mod_exp(res->bignum_, bignum->bignum_, exp->bignum_, bn->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -702,7 +898,11 @@
   BigNum *exp = new BigNum(x);
 
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_exp(&res->bignum_, &bignum->bignum_, &exp->bignum_, ctx);
+#else
+  BN_exp(res->bignum_, bignum->bignum_, exp->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -715,7 +915,11 @@
 
   BigNum *res = new BigNum();
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_rand_range(&res->bignum_, &bignum->bignum_);
+#else
+  BN_rand_range(res->bignum_, bignum->bignum_);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -729,7 +933,11 @@
 
   BigNum *res = new BigNum();
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_generate_prime_ex(&res->bignum_, x, safe, NULL, NULL, NULL);
+#else
+  BN_generate_prime_ex(res->bignum_, x, safe, NULL, NULL, NULL);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -743,7 +951,11 @@
 
   REQ_UINT32_ARG(0, reps);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   info.GetReturnValue().Set(Nan::New<Number>(BN_is_prime_ex(&bignum->bignum_, reps, ctx, NULL)));
+#else
+  info.GetReturnValue().Set(Nan::New<Number>(BN_is_prime_ex(bignum->bignum_, reps, ctx, NULL)));
+#endif
 }
 
 NAN_METHOD(BigNum::IsBitSet)
@@ -752,7 +964,11 @@
 
   REQ_UINT32_ARG(0, n);
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   info.GetReturnValue().Set(Nan::New<Number>(BN_is_bit_set(&bignum->bignum_, n)));
+#else
+  info.GetReturnValue().Set(Nan::New<Number>(BN_is_bit_set(bignum->bignum_, n)));
+#endif
 }
 
 NAN_METHOD(BigNum::Bcompare)
@@ -761,7 +977,11 @@
 
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   info.GetReturnValue().Set(Nan::New<Number>(BN_cmp(&bignum->bignum_, &bn->bignum_)));
+#else
+  info.GetReturnValue().Set(Nan::New<Number>(BN_cmp(bignum->bignum_, bn->bignum_)));
+#endif
 }
 
 NAN_METHOD(BigNum::Scompare)
@@ -770,7 +990,11 @@
 
   REQ_INT64_ARG(0, x);
   BigNum *bn = new BigNum(x);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   int res = BN_cmp(&bignum->bignum_, &bn->bignum_);
+#else
+  int res = BN_cmp(bignum->bignum_, bn->bignum_);
+#endif
 
   info.GetReturnValue().Set(Nan::New<Number>(res));
 }
@@ -782,6 +1006,7 @@
   REQ_UINT64_ARG(0, x);
   int res;
   if (sizeof(BN_ULONG) >= 8 || x <= 0xFFFFFFFFL) {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     BIGNUM bn;
     BN_init(&bn);
     BN_set_word(&bn, x);
@@ -791,6 +1016,17 @@
     BigNum *bn = new BigNum(x);
     res = BN_cmp(&bignum->bignum_, &bn->bignum_);
   }
+#else
+    BIGNUM *bn;
+    bn = BN_new();
+    BN_set_word(bn, x);
+    res = BN_cmp(bignum->bignum_, bn);
+    BN_clear_free(bn);
+  } else {
+    BigNum *bn = new BigNum(x);
+    res = BN_cmp(bignum->bignum_, bn->bignum_);
+  }
+#endif
 
   info.GetReturnValue().Set(Nan::New<Number>(res));
 }
@@ -892,8 +1128,13 @@
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   bool bignumNegative = BN_is_negative(&bignum->bignum_);
   bool bnNegative = BN_is_negative(&bn->bignum_);
+#else
+  bool bignumNegative = BN_is_negative(bignum->bignum_);
+  bool bnNegative = BN_is_negative(bn->bignum_);
+#endif
 
   BigNum *res = new BigNum();
 
@@ -901,8 +1142,13 @@
   // Portions Copyright (c) Agora S.A.
   // Licensed under the MIT License.
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   int payloadSize = BN_bn2mpi(&bignum->bignum_, NULL);
   int maskSize = BN_bn2mpi(&bn->bignum_, NULL);
+#else
+  int payloadSize = BN_bn2mpi(bignum->bignum_, NULL);
+  int maskSize = BN_bn2mpi(bn->bignum_, NULL);
+#endif
 
   uint32_t size = max(payloadSize, maskSize);
   int offset = abs(payloadSize - maskSize);
@@ -919,8 +1165,13 @@
   uint8_t* payload = (uint8_t*) calloc(size, sizeof(char));
   uint8_t* mask = (uint8_t*) calloc(size, sizeof(char));
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_bn2mpi(&bignum->bignum_, payload + payloadOffset);
   BN_bn2mpi(&bn->bignum_, mask + maskOffset);
+#else
+  BN_bn2mpi(bignum->bignum_, payload + payloadOffset);
+  BN_bn2mpi(bn->bignum_, mask + maskOffset);
+#endif
 
   if (payloadSize < maskSize) {
     shiftSizeAndMSB(payload, mask, payloadOffset);
@@ -989,7 +1240,11 @@
     twos_complement2mpi(payload + BN_PAYLOAD_OFFSET, size - BN_PAYLOAD_OFFSET);
   }
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_mpi2bn(payload, size, &res->bignum_);
+#else
+  BN_mpi2bn(payload, size, res->bignum_);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -1021,7 +1276,11 @@
 
   BigNum *bn = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_mod_inverse(&res->bignum_, &bignum->bignum_, &bn->bignum_, ctx);
+#else
+  BN_mod_inverse(res->bignum_, bignum->bignum_, bn->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
 
@@ -1042,7 +1301,11 @@
 {
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   int size = BN_num_bits(&bignum->bignum_);
+#else
+  int size = BN_num_bits(bignum->bignum_);
+#endif
   Local<Value> result = Nan::New<Integer>(size);
 
   info.GetReturnValue().Set(result);
@@ -1056,7 +1319,11 @@
   BigNum *bi = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   BigNum *res = new BigNum();
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   BN_gcd(&res->bignum_, &bignum->bignum_, &bi->bignum_, ctx);
+#else
+  BN_gcd(res->bignum_, bignum->bignum_, bi->bignum_, ctx);
+#endif
 
   WRAP_RESULT(res, result);
   info.GetReturnValue().Set(result);
@@ -1070,10 +1337,17 @@
   BigNum *bn_n = Nan::ObjectWrap::Unwrap<BigNum>(info[0]->ToObject());
   int res = 0;
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   if (BN_jacobi_priv(&bn_a->bignum_, &bn_n->bignum_, &res, ctx) == -1) {
     Nan::ThrowError("Jacobi symbol calculation failed");
     return;
   }
+#else
+  if (BN_jacobi_priv(bn_a->bignum_, bn_n->bignum_, &res, ctx) == -1) {
+    Nan::ThrowError("Jacobi symbol calculation failed");
+    return;
+  }
+#endif
 
   info.GetReturnValue().Set(Nan::New<Integer>(res));
 }
@@ -1082,10 +1356,11 @@
 {
   BigNum *bignum = Nan::ObjectWrap::Unwrap<BigNum>(info.This());
 
-  unsigned int nCompact = info[0]->ToUint32()->Value();
+  unsigned int nCompact = Nan::To<uint32_t>(info[0]).FromJust();
   unsigned int nSize = nCompact >> 24;
   bool fNegative     =(nCompact & 0x00800000) != 0;
   unsigned int nWord = nCompact & 0x007fffff;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
   if (nSize <= 3)
   {
       nWord >>= 8*(3-nSize);
@@ -1097,6 +1372,19 @@
       BN_lshift(&bignum->bignum_, &bignum->bignum_, 8*(nSize-3));
   }
   BN_set_negative(&bignum->bignum_, fNegative);
+#else
+  if (nSize <= 3)
+  {
+      nWord >>= 8*(3-nSize);
+      BN_set_word(bignum->bignum_, nWord);
+  }
+  else
+  {
+      BN_set_word(bignum->bignum_, nWord);
+      BN_lshift(bignum->bignum_, bignum->bignum_, 8*(nSize-3));
+  }
+  BN_set_negative(bignum->bignum_, fNegative);
+#endif
 
   info.GetReturnValue().Set(info.This());
 }
diff -urN a/package.json b/package.json
--- a/package.json	2016-06-16 19:48:22.000000000 +0900
+++ b/package.json	2018-06-28 16:01:29.473813555 +0900
@@ -22,14 +22,14 @@
     "url": "http://www.justmoon.net"
   },
   "dependencies": {
-    "nan": "^2.3.4",
-    "node-pre-gyp": "~0.6.28"
+    "nan": "^2.10.0",
+    "node-pre-gyp": "~0.10.2"
   },
   "devDependencies": {
     "aws-sdk": "~2.4.0",
     "put": "~0.0.5",
     "standard": "~7.1.2",
-    "tap": "~5.7.2"
+    "tap": "~12.0.1"
   },
   "scripts": {
     "install": "node-pre-gyp install --fallback-to-build",
